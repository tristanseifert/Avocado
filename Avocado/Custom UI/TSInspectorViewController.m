//
//  TSInspectorView.m
//  Avocado
//
//  Created by Tristan Seifert on 20160514.
//  Copyright Â© 2016 Tristan Seifert. All rights reserved.
//

#import "TSInspectorViewController.h"

NSString * const TSInspectorStateIndexKey = @"TSInspectorStateIndex";
NSString * const TSInspectorStateExpandedKey = @"TSInspectorStateExpanded";
NSString * const TSInspectorStateRestorableKey = @"TSInspectorStateRestorableKey";

@interface TSInspectorViewController ()

- (void) commonInit;

@property (nonatomic) IBOutlet NSStackView *stackView;

@property (nonatomic) NSLayoutConstraint *widthConstraint;
@property (nonatomic) NSLayoutConstraint *heightConstraint;

/// array of inspector panels
@property (nonatomic) NSMutableArray<TSInspectorViewItem *> *panels;

- (void) addWidthConstraint;

@end

@implementation TSInspectorViewController

#pragma mark Initialization
/**
 * Sets up stuff when the controller is created.
 */
- (void) awakeFromNib {
	[super awakeFromNib];
	
	[self commonInit];
}

/**
 * Sets up the stack view to have the settings we desire.
 */
- (void) commonInit {
	self.stackView.wantsLayer = YES;
	self.stackView.layerContentsRedrawPolicy = NSViewLayerContentsRedrawOnSetNeedsDisplay;

	// set up stack view properties
	self.stackView.orientation = NSUserInterfaceLayoutOrientationVertical;
	
	self.stackView.alignment = NSLayoutAttributeLeading;
	self.stackView.distribution = NSStackViewDistributionFill;
	
	self.stackView.detachesHiddenViews = YES;
	self.stackView.spacing = 0.f;
	
	// we strongly hug the sides of the views it contains
	[self.stackView setHuggingPriority:NSLayoutPriorityDefaultLow
						forOrientation:NSLayoutConstraintOrientationHorizontal];
	
	// we shall grow and shrink as its internal views grow, are added, or are removed
	[self.stackView setHuggingPriority:NSLayoutPriorityDefaultHigh
						forOrientation:NSLayoutConstraintOrientationVertical];
	
	// set up panels
	self.panels = [NSMutableArray new];
	
	// add constraint
	[self addWidthConstraint];
}

#pragma mark Sizing
/**
 * Adds the width constraint so that it fills the width of the scroll
 * view that the view is in.
 */
- (void) addWidthConstraint {
	if(self.stackView.superview != nil && self.stackView.enclosingScrollView) {
		NSLayoutConstraint *c;
		NSScrollView *scroll = self.stackView.enclosingScrollView;
		
		// build the equal widths constraint; priority = 1000
		c = [NSLayoutConstraint constraintWithItem:self.stackView
										 attribute:NSLayoutAttributeWidth
										 relatedBy:NSLayoutRelationEqual
											toItem:scroll.contentView
										 attribute:NSLayoutAttributeWidth
										multiplier:1.f constant:0.f];
		c.priority = NSLayoutPriorityRequired;
		
		self.widthConstraint = c;
		[scroll addConstraint:self.widthConstraint];
		
		
//		// build the greater than or equal height constraint; priority = 1000
//		c = [NSLayoutConstraint constraintWithItem:self.stackView
//										 attribute:NSLayoutAttributeHeight
//										 relatedBy:NSLayoutRelationGreaterThanOrEqual
//											toItem:scroll.contentView
//										 attribute:NSLayoutAttributeHeight
//										multiplier:1.f constant:0.f];
//		c.priority = NSLayoutPriorityRequired;
//		
//		self.heightConstraint = c;
//		[scroll addConstraint:self.heightConstraint];
	}
}

#pragma mark Inspector Handling
/**
 * Appends an inspector to the end of the view.
 */
- (void) addInspectorView:(TSInspectorViewItem *) controller {
	[self.panels addObject:controller];
	
	[self.stackView addView:controller.view inGravity:NSStackViewGravityCenter];
}

/**
 * Inserts an inspector view at the given index.
 */
- (void) insertInspectorView:(TSInspectorViewItem *) controller atIndex:(NSUInteger) index {
	[self.panels insertObject:controller atIndex:index];
	
	[self.stackView insertView:controller.view atIndex:index inGravity:NSStackViewGravityCenter];
}


/**
 * Removes a previously added inspector view.
 */
- (void) removeInspectorView:(TSInspectorViewItem *) controller {
	[self.panels removeObject:controller];
	
	[self.stackView removeView:controller.view];
}

/**
 * Returns a non-mutable copy of the inspector panels array.
 */
- (NSArray<TSInspectorViewItem *> *) inspectorItems {
	return [self.panels copy];
}

+ (NSSet *) keyPathsForValuesAffectingInspectorItems {
	return [NSSet setWithObject:@"panels"];
}

#pragma mark State Handling
/**
 * Restores the inspector state (including that of its palettes) by parsing
 * the contents of an NSDictionary previously generated by accessing the
 * stateDict property.
 */
- (void) restoreWithState:(NSDictionary *) state {
	[state enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSDictionary *obj, BOOL *stop) {
		// find the corresponding view item
		TSInspectorViewItem __block *inspectorItem;
		
		[self.panels enumerateObjectsUsingBlock:^(TSInspectorViewItem *i, NSUInteger idx, BOOL *stop) {
			// check if their class names are the same
			if([i.content.className isEqualToString:key]) {
				inspectorItem = i;
				*stop = YES;
			}
		}];
		
		// restore its index
		NSUInteger idx = [obj[TSInspectorStateIndexKey] integerValue];
		
		[self.panels removeObject:inspectorItem];
		[self.panels insertObject:inspectorItem atIndex:idx];
		
		// set whether it's expanded
		BOOL expanded = [obj[TSInspectorStateExpandedKey] boolValue];
		inspectorItem.expanded = expanded;
		
		// check if there's restorable state
		NSData *restorable = obj[TSInspectorStateRestorableKey];
		
		if(restorable != nil) {
			// if so, give the view controller the opportunity to decode it
			NSKeyedUnarchiver *unArc = [[NSKeyedUnarchiver alloc] initForReadingWithData:restorable];
			unArc.requiresSecureCoding = YES;
			
			[inspectorItem.content restoreStateWithCoder:unArc];
			
			[unArc finishDecoding];
		}
	}];
}

/**
 * Returns a dictionary containing information for restoring the state of the
 * inspector panels (expansion, size, etc) at a later time.
 */
- (NSDictionary *) stateDict {
	NSMutableDictionary *dict = [NSMutableDictionary new];
	
	[self.panels enumerateObjectsUsingBlock:^(TSInspectorViewItem *item, NSUInteger idx, BOOL *stop) {
		// create a subdict with info (index, expanded)
		NSMutableDictionary *info = [NSMutableDictionary new];
		
		info[TSInspectorStateIndexKey] = @(idx);
		info[TSInspectorStateExpandedKey] = @(item.expanded);
		
		// save any state the inspector may have
		NSMutableData *data = [NSMutableData new];
		
		NSKeyedArchiver *arc = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];
		arc.requiresSecureCoding = YES;
		
		[item.content encodeRestorableStateWithCoder:arc];
		
		[arc finishEncoding];
		info[TSInspectorStateRestorableKey] = [data copy];
		
		// insert it
		NSString *key = item.content.className;
		dict[key] = [info copy];
	}];
	
	return [dict copy];
}

@end
